/*
 * Copyright 2021 The Gort Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package templates

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	"text/template"

	"github.com/getgort/gort/data"
)

type OutputElement interface {
	SetLast(int)
	Last() int
	SetFirst(int)
	First() int
	String() string
}

type OutputElements struct {
	Color    string
	Title    string
	Elements []OutputElement
}

func TransformAndEncode(tmpl string, envelope data.CommandResponseEnvelope) (OutputElements, error) {
	enc, err := Transform(tmpl, envelope)
	if err != nil {
		return OutputElements{}, err
	}

	return EncodeElements(enc)
}

func calculateLineNumber(text string, index int) int {
	if index < 0 {
		return -1
	}

	lines := strings.Split(text, "\n")

	for i, left := 0, index; i < len(lines); i++ {
		length := len(lines[i]) + 1

		if left < length {
			return i + 1
		}

		left -= length
	}

	return -1
}

// Encodes intermediate text generated by Transform into an OutputElements value
// that can be passed to an adapter.
func EncodeElements(text string) (OutputElements, error) {
	var lastText *Text
	var lastSection *Section
	var elements OutputElements

	for tag, jsn, first, last := nextTag(text, 0); first != -1; tag, jsn, first, last = nextTag(text, last) {
		var e OutputElement

		switch tag {
		case "":
			continue
		// no-op

		case "Divider":
			e = &Divider{}

		case "Image":
			o := &Image{}
			json.Unmarshal([]byte(jsn), o)
			e = o

		case "Section":
			o := &Section{}
			o.SetFirst(first)
			o.SetLast(last)
			json.Unmarshal([]byte(jsn), o)
			lastSection = o
		case "SectionEnd":
			if lastSection == nil {
				lineNumber := calculateLineNumber(text, first)
				return OutputElements{}, fmt.Errorf("unmatched {{sectionend}} tag on line %d", lineNumber)
			}
			e = lastSection
			first = lastText.First()
			lastSection = nil

		case "Text":
			o := &Text{}
			o.SetFirst(first)
			o.SetLast(last)
			json.Unmarshal([]byte(jsn), o)
			lastText = o
		case "TextEnd":
			if lastText == nil {
				lineNumber := calculateLineNumber(text, first)
				return OutputElements{}, fmt.Errorf("unmatched {{textend}} tag on line %d", lineNumber)
			}

			lastText.Text = text[lastText.Last()+1 : first]
			e = lastText
			first = lastText.FirstIndex
			lastText = nil

		default:
			return OutputElements{}, fmt.Errorf("unsupported tag {{ %s }}", tag)
		}

		if e == nil {
			continue
		}

		e.SetFirst(first)
		e.SetLast(last)
		elements.Elements = append(elements.Elements, e)
	}

	if lastSection != nil {
		lineNumber := calculateLineNumber(text, lastSection.First())
		return OutputElements{}, fmt.Errorf("unmatched {{section}} tag on line %d", lineNumber)
	}
	if lastText != nil {
		lineNumber := calculateLineNumber(text, lastText.First())
		return OutputElements{}, fmt.Errorf("unmatched {{text}} tag on line %d", lineNumber)
	}

	return elements, nil
}

// Transforms template text + envelope, resulting in intermediate text that
// can be encoded into an OutputElements value.
func Transform(tmpl string, envelope data.CommandResponseEnvelope) (string, error) {
	t, err := template.New(envelope.Request.String()).Funcs(FunctionMap()).Parse(tmpl)
	if err != nil {
		return "", err
	}

	b := new(bytes.Buffer)
	err = t.Execute(b, envelope)
	if err != nil {
		return "", err
	}

	return b.String(), nil
}

// nextTag returns the tag, JSON text, and start and end tags for the next tag
// after start. If no tag is found, the index values are both returned as -1.
func nextTag(text string, start int) (tag string, json string, first int, last int) {
	if start >= len(text) {
		return "", "", -1, -1
	}

	text = text[start:]

	i, j := strings.Index(text, "<<"), strings.Index(text, ">>")
	if i < 0 || j < 0 {
		return "", "", -1, -1
	}

	first = i + start
	last = j + start + 1
	text = text[i+2 : j]

	if m := strings.Index(text, "|{"); m == -1 {
		tag = text
	} else {
		tag = text[:m]
		json = text[m+1:]
	}

	return tag, json, first, last
}
