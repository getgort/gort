/*
 * Copyright 2021 The Gort Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package templates

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	"text/template"

	"github.com/getgort/gort/data"
)

type OutputElement interface {
	First() int
	Last() int
	String() string
}

type WithAlt interface {
	Alt() string
}

type OutputElements struct {
	// Color is the representation of the RGB color hex code. If defined, it
	// MUST adhere to the format "#RRGGBB". Optional.
	Color string

	// Title is the title of the message, if set. Optional.
	Title string

	// Elements includes the various message construction elements.
	Elements []OutputElement
}

// Alt returns simplified text for this output.
// It will either return a concatenation of the text form for each element, separated by newlines,
// or the first Alt element.
func (o *OutputElements) Alt() string {
	var out string = o.Title
	for _, element := range o.Elements {
		switch t := element.(type) {
		case *Alt:
			return t.Text
		default:
			if a, isAlt := element.(WithAlt); isAlt {
				out = fmt.Sprintf("%v\n\n%v", out, a.Alt())
			}
		}
	}
	return out
}

func TransformAndEncode(tmpl string, envelope data.CommandResponseEnvelope) (OutputElements, error) {
	enc, err := Transform(tmpl, envelope)
	if err != nil {
		return OutputElements{}, err
	}

	return EncodeElements(enc)
}

func calculateLineNumber(text string, index int) int {
	if index < 0 {
		return -1
	}

	lines := strings.Split(text, "\n")

	for i, left := 0, index; i < len(lines); i++ {
		length := len(lines[i]) + 1

		if left < length {
			return i + 1
		}

		left -= length
	}

	return -1
}

// Encodes intermediate text generated by Transform into an OutputElements value
// that can be passed to an adapter.
func EncodeElements(text string) (OutputElements, error) {
	var header *Header
	var lastSection *Section
	var lastText *Text

	var elements OutputElements

	for tag, jsn, first, last := nextTag(text, 0); first != -1; tag, jsn, first, last = nextTag(text, last) {
		etag := Tag{FirstIndex: first, LastIndex: last}

		switch tag {
		case "":
			continue

		case "Divider":
			switch {
			case lastSection != nil:
				return encodingError(text, first, "illegal {{divider}} in {{section}} on line %d")
			case lastText != nil:
				return encodingError(text, first, "illegal {{divider}} in {{text}} on line %d")
			default:
				elements.Elements = append(elements.Elements, &Divider{Tag: etag})
			}

		case "Header":
			switch {
			case header != nil:
				return encodingError(text, first, "duplicate {{header}} on line %d")
			case len(elements.Elements) != 0:
				return encodingError(text, first, "unexpected {{header}} on line %d; header must be the first element")
			default:
				o := &Header{Tag: etag}
				json.Unmarshal([]byte(jsn), o)
				elements.Elements = append(elements.Elements, o)
			}

		case "Image":
			o := &Image{Tag: etag}
			json.Unmarshal([]byte(jsn), o)

			switch {
			case lastText != nil:
				return encodingError(text, first, "illegal {{image}} in {{text}} on line %d")
			case lastSection != nil:
				lastSection.Fields = append(lastSection.Fields, o)
			default:
				elements.Elements = append(elements.Elements, o)
			}

		case "Section":
			switch {
			case lastSection != nil:
				return encodingError(text, first, "illegal {{section}} in {{section}} on line %d")
			case lastText != nil:
				return encodingError(text, first, "illegal {{section}} in {{text}} on line %d")
			default:
				o := &Section{Tag: etag}
				json.Unmarshal([]byte(jsn), o)
				lastSection = o
			}

		case "SectionEnd":
			switch {
			case lastSection == nil:
				return encodingError(text, first, "unmatched {{endsection}} on line %d")
			default:
				lastSection.Tag.LastIndex = last
				elements.Elements = append(elements.Elements, lastSection)
				lastSection = nil
			}

		case "Text":
			o := &Text{Tag: etag}
			json.Unmarshal([]byte(jsn), o)

			switch {
			case lastText != nil:
				return encodingError(text, first, "illegal {{text}} in {{text}} on line %d")
			default:
				lastText = o
			}

		case "TextEnd":
			switch {
			case lastText == nil:
				return encodingError(text, first, "unmatched {{endtext}} on line %d")
			case lastSection != nil:
				lastText.Text = text[lastText.Last()+1 : first]
				lastText.Tag.LastIndex = last
				lastSection.Fields = append(lastSection.Fields, lastText)
				lastText = nil
			default:
				lastText.Text = text[lastText.Last()+1 : first]
				lastText.Tag.LastIndex = last
				elements.Elements = append(elements.Elements, lastText)
				lastText = nil
			}
		case "Unimplemented":
			elements.Elements = append(elements.Elements, &Unimplemented{Tag: etag})

		case "Alt":
			o := &Alt{Tag: etag}
			json.Unmarshal([]byte(jsn), o)
			elements.Elements = append(elements.Elements, o)

		default:
			return OutputElements{}, fmt.Errorf("unsupported {{ %s }}", tag)
		}
	}

	if lastSection != nil {
		lineNumber := calculateLineNumber(text, lastSection.First())
		return OutputElements{}, fmt.Errorf("unmatched {{section}} on line %d", lineNumber)
	}
	if lastText != nil {
		lineNumber := calculateLineNumber(text, lastText.First())
		return OutputElements{}, fmt.Errorf("unmatched {{text}} on line %d", lineNumber)
	}

	return elements, nil
}

// Transforms template text + envelope, resulting in intermediate text that
// can be encoded into an OutputElements value.
func Transform(tmpl string, envelope data.CommandResponseEnvelope) (string, error) {
	t, err := template.New(envelope.Request.String()).Funcs(FunctionMap()).Parse(tmpl)
	if err != nil {
		return "", err
	}

	b := new(bytes.Buffer)
	err = t.Execute(b, envelope)
	if err != nil {
		return "", err
	}

	return b.String(), nil
}

func encodingError(text string, index int, format string) (OutputElements, error) {
	return OutputElements{}, fmt.Errorf(format, calculateLineNumber(text, index))
}

// nextTag returns the tag, JSON text, and start and end tags for the next tag
// after start. If no tag is found, the index values are both returned as -1.
func nextTag(text string, start int) (tag string, json string, first int, last int) {
	if start >= len(text) {
		return "", "", -1, -1
	}

	text = text[start:]

	i, j := strings.Index(text, "<<"), strings.Index(text, ">>")
	if i < 0 || j < 0 {
		return "", "", -1, -1
	}

	first = i + start
	last = j + start + 1
	text = text[i+2 : j]

	if m := strings.Index(text, "|{"); m == -1 || m > j {
		tag = text
	} else {
		tag = text[:m]
		json = text[m+1:]
	}

	return tag, json, first, last
}
